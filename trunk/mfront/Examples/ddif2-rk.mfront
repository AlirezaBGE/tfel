@Parser    RungeKutta;
@Behaviour DDIF2RK;
@Author    Helfer Thomas;
@Algorithm rk54;
@Date 28/07/06;

@Epsilon 1.e-10;
@MinimalTimeStep 1.e-50;

@Includes{
#include<utility>
#include<algorithm>
#include"TFEL/Math/TinyMatrixSolve.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/DDIF2Base.hxx"
}

@Coef real young; /* mandatory for castem */
young.setGlossaryName("YoungModulus");
@Coef real nu;    /* mandatory for castem */
nu.setGlossaryName("PoissonRatio");
@Coef real rho;   /* mandatory for castem */
rho.setGlossaryName("MassDensity");
@Coef real alpha; /* mandatory for castem */
alpha.setGlossaryName("ThermalExpansion");
@Coef real A;
A.setGlossaryName("NortonCoefficient");
@Coef real E;
E.setGlossaryName("NortonExponent");
@Coef real sigr; 
sigr.setGlossaryName("FractureStress");

@LocalVar real lambda;
@LocalVar real mu;

@StateVar real e0;  // strain in first  direction
@StateVar real e1;  // strain in second direction
@StateVar real e2;  // strain in third direction
@StateVar real p;   // cumulated viscoplastic strain
@AuxiliaryStateVar real e0m; // hardening in first  direction
@AuxiliaryStateVar real e1m; // hardening in second direction
@AuxiliaryStateVar real e2m; // hardening in third direction

@LocalVar Stensor n0;
@LocalVar Stensor n1;
@LocalVar Stensor n2;

/* Initialize Lame coefficients */
@InitLocalVars{
  using namespace tfel::material::lame;
  lambda = computeLambda(1.,nu);
  mu = computeMu(1.,nu);
  // directions 
  n0 = Stensor(real(0.));
  n1 = Stensor(real(0.));
  n2 = Stensor(real(0.));
  n0(0) = real(1.);
  n1(1) = real(1.);
  n2(2) = real(1.);
  // change to cylindrical coordinates
  DDIF2Base::cart2cyl(deto,0.);
} // end of @InitLocalVars

@ComputeStress{
  sig = young*lambda*trace(eel)*Stensor::Id()+2*young*mu*eel;
} // end of @ComputeStresss

@Derivative{
  tmatrix<3,3,real> m;
  tvector<3,real>  v;
  //  creep
  const real sigeq = min(sigmaeq(sig),500.e6);
  if(sigeq>1.e9){
    return false;
  }
  real inv_sigeq(0);
  Stensor  n(0.);
  if(sigeq > 1.){
    inv_sigeq = 1/sigeq;
  }
  n     = 1.5f*deviator(sig)*inv_sigeq;
  dp    = A*pow(sigeq,E);
  Stensor devp = dp*n;
  //Fracture
  const real Rp = -0.5;  
  real tr  = lambda*(trace(deto-devp));
  real ds0 = tr+2*mu*(deto(0)-devp(0));
  real ds1 = tr+2*mu*(deto(1)-devp(1));
  real ds2 = tr+2*mu*(deto(2)-devp(2));
  DDIF2Base::rk(m,v,sig(0),ds0,
		e0,e0m,sigr,Rp,young,
		lambda,mu,0,1,2);
  DDIF2Base::rk(m,v,sig(1),ds1,
		e1,e1m,sigr,Rp,young,
		lambda,mu,1,0,2);
  DDIF2Base::rk(m,v,sig(2),ds2,
		e2,e2m,sigr,Rp,young,
		lambda,mu,2,0,1);
  TinyMatrixSolve<3,real>::exe(m,v);
  de0 = v(0);
  de1 = v(1);
  de2 = v(2);
  tr  = lambda*(trace(deto-devp)-de0-de1-de2);
  ds0 = tr+2*mu*(deto(0)-devp(0)-de0);
  ds1 = tr+2*mu*(deto(1)-devp(1)-de1);
  ds2 = tr+2*mu*(deto(2)-devp(2)-de2);
  DDIF2Base::rk2(de0,sig(0),ds0,
		 e0,e0m,sigr,Rp,young,
		 lambda,mu,dt);
  DDIF2Base::rk2(de1,sig(1),ds1,
		 e1,e1m,sigr,Rp,young,
		 lambda,mu,dt);
  DDIF2Base::rk2(de2,sig(2),ds2,
		 e2,e2m,sigr,Rp,young,
		 lambda,mu,dt);

  Stensor de_fis = de0*n0+de1*n1+de2*n2;
  /* elasticity */
  deel=deto-de_fis-devp;
}

@UpdateAuxiliaryStateVars{
  if(e0<0){
    eel(0) += e0;
    e0 = 0.;
  }
  if(e1<0){
    eel(1) += e1;
    e1 = 0.;
  }
  if(e2<0){
    eel(2) += e2;
    e2 = 0.;
  }
  e0m=max(e0m,e0);
  e1m=max(e1m,e1);
  e2m=max(e2m,e2);
  // change to cartesian coordinates
  DDIF2Base::cyl2cart(sig,0.);
}
