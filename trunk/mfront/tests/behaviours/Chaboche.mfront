/*!
 * \file   chaboche.mfront
 * \brief  resolution implicite jabobienne numerique
 * \author jmp (from TH)
 * \date   18 02 2013
 */

@Parser Implicit;
@Behaviour Chaboche;
@Algorithm NewtonRaphson_NumericalJacobian;

@Theta 1. ;
@Epsilon 1.e-12;

@MaterialProperty real young; /* mandatory for castem */
young.setGlossaryName("YoungModulus");
@MaterialProperty real nu;    /* mandatory for castem */
nu.setGlossaryName("PoissonRatio");
@MaterialProperty real rho;   /* mandatory for castem */
rho.setGlossaryName("MassDensity");
@MaterialProperty real alpha; /* mandatory for castem */
alpha.setGlossaryName("ThermalExpansion");

@MaterialProperty stress R_inf;
@MaterialProperty stress R_0;
@MaterialProperty real b;
@MaterialProperty real k;
@MaterialProperty real w;
@MaterialProperty stress C1_inf;
@MaterialProperty stress C2_inf;
@MaterialProperty real   g1_0;
@MaterialProperty real   g2_0;
@MaterialProperty real   a_inf;

@Includes{
#include"TFEL/Material/Lame.hxx"
}

@StateVariable strain    p;
@StateVariable StrainStensor a[2];

@LocalVariable stress        lambda;
@LocalVariable stress        mu;
@LocalVariable StressStensor s0;

/* Initialize Lame coefficients */
@InitLocalVars{
  using namespace tfel::material::lame;
  lambda = computeLambda(young,nu);
  mu     = computeMu(young,nu);
  s0     = lambda*trace(eto+deto)*Stensor::Id()+2*mu*(eto+deto);
} 

@TangentOperator{
  using namespace tfel::material::lame;
  if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
    computeElasticStiffness<N,Type>::exe(Dt,lambda,mu);
  } else if (smt==CONSISTANTTANGENTOPERATOR){
    StiffnessTensor De;
    Stensor4 Je;
    computeElasticStiffness<N,Type>::exe(De,lambda,mu);
    getPartialJacobianInvert(Je);
    Dt = De*Je;
  } else {
    return false;
  }
}

@ComputeStress{
  sig = lambda*trace(eel)*Stensor::Id()+2*mu*eel;
} 

@Integrator{
  const real eps           = 1.e-12;
  const real M_2_3         = real(2)/real(3);
  const real C_inf[2]={C1_inf,C2_inf};
  const real g_0[2]={g1_0,g2_0};
  // Les variables post-fixee par un _ sont exprimees les valeurs en
  // t+theta*dt
  const strain p_           = p +theta*dp ;
  const stress Rp_          = R_inf + (R_0-R_inf)*exp(-b*p_) ;
  // ces exponentielles sont communes aux deux ecrouissages
  const real tmpC0          = (1.+(k-1.)*exp(-w*p));
  const real tmpC           = (1.+(k-1.)*exp(-w*p_));
  const real tmpG           = (a_inf+(1-a_inf)*exp(-b*p_));
  StressStensor sr_         = deviator(sig);
  StressStensor sigel       = s0;  
  StrainStensor a_[2];
  real g_[2];
  
  for(unsigned short i=0;i!=2;++i){
     const stress C_         = C_inf[i]*tmpC;
     const stress Cel        = C_inf[i]*tmpC0;
     g_[i]                   = g_0[i]*tmpG;
     a_[i]                   = a[i]+theta*da[i];
     const StressStensor X_  = M_2_3*C_*a_[i];
     sr_                    -= X_;
     sigel                  -= Cel*a[i]*M_2_3 ;
  }
  
  // ajout  test sur predicteur elastique
  const real seqel = sigmaeq(sigel);
  const real Rpel  = R_inf + (R_0-R_inf)*exp(-b*p) ;
  const real Fel   = seqel - Rpel ;
  if(Fel > 0){
    Stensor n_(real(0));
    const stress        seq_ = sigmaeq(sr_);
    if(seq_>eps*young){
      n_ = 1.5*sr_/seq_;
    }
    feel += dp*n_-deto;
    fp    = (seq_-Rp_)/young;
    for(unsigned short i=0;i!=2;++i){
      fa[i]  -= dp*(n_-g_[i]*a_[i]);
    }
  } else {
    feel -= deto;
  }
//cout << "J : " << jacobian << endl;
} 
